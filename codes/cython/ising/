# Ising model simulation 
#
#
#

import cython
import numpy as np
cimport numpy as np
import matplotlib.pyplot as plt
from numpy.random import rand


cdef extern void cIsing (double* A, double* B, double* C, double* D, int Npoints, int Nsites)
cdef extern from "../../c-cpp/utils/mt19937ar.h" nogil:
    pass
cdef extern from "../../c-cpp/utils/mt19937ar.c" nogil:
    double genrand_real2()
    double init_genrand(unsigned long)
@cython.wraparound(False)
@cython.boundscheck(False)
@cython.cdivision(True)
@cython.nonecheck(False)
cdef class Ising:
    cdef int Ns 
    def __init__(self, Ns):
        pass
    
    cpdef oneD(self, np.ndarray[double, ndim=1, mode="c"] A, np.ndarray[double, ndim=1, mode="c"] B, np.ndarray[double, ndim=1, mode="c"] C, np.ndarray[double, ndim=1, mode="c"] D, int Npoints, int Nsites):
        cIsing (&A[0], &B[0], &C[0], &D[0], Npoints, Nsites)
        return 


    def twoD(self, int N, int nt, config, Tot_E, Tot_M, temp):
        ##  MAIN PART OF THE CODE
        for m in range(len(temp)):
            def initialstate(N):    # generates a random spin config
                state = 2*np.random.randint(2, size=(N,N))-1
                return state

            ## This is to equilibrate the system
            EQM = 20
            config = initialstate(N)
            for i in range(EQM):
                mcmove(config, 1.0/temp[m], N)

            ## This part does the main calculations and the measurements
            msrmnt = 200
            for i in range(msrmnt):
                mcmove(config, 1.0/temp[m], N)   # monte carlo moves
                E = calcEnergy(config, N)        # calculate the energy
                M = calcMag(config)           # calculate the magnetisation  
                Tot_E[m] = Tot_E[m] + E
                Tot_M[m] = Tot_M[m] + M
                    
        Tot_E = Tot_E/(2*msrmnt*N*N)
        Tot_M = Tot_M/(msrmnt*N*N)
        # plot the energy and magnetisation
        f = plt.figure(figsize=(18, 5), dpi=80, facecolor='w', edgecolor='k');    

        sp =  f.add_subplot(1, 2, 1 );
        plt.plot(temp, Tot_E, 'o', color="#A60628", label=' Energy (E)');
        plt.legend(loc='lower right', fontsize=15); 
        plt.xlabel("Temperature (T)", fontsize=20);

        sp =  f.add_subplot(1, 2, 2 );
        plt.plot(temp, Tot_M, '*', label='Magnetisation (m)');
        plt.legend(loc='lower right', fontsize=15); 
        plt.xlabel("Temperature (T)", fontsize=20);
        plt.show()
        return

def mcmove(config, beta, N):
    for i in range(N):
        for j in range(N):            
                a = np.random.randint(0, N)
                b = np.random.randint(0, N)
                s =  config[a, b]
                nb = config[(a+1)%N,b] + config[a,(b+1)%N] + config[(a-1)%N,b] + config[a,(b-1)%N]
                cost = 2*s*nb
                if cost < 0:    
                    s *= -1
                elif rand() < np.exp(-cost*beta):
                    s *= -1
                config[a, b] = s
    return config

## Energy calculation
def calcEnergy(config, N):
    energy = 0
    for i in range(len(config)):
        for j in range(len(config)):
            S = config[i,j]
            nb = config[(i+1)%N, j] + config[i,(j+1)%N] + config[(i-1)%N, j] + config[i,(j-1)%N]
            energy += -nb*S 
    return energy/2. 

## magnetization of  the configuration
def calcMag(config):                
    mag = np.sum(config)
    return mag


